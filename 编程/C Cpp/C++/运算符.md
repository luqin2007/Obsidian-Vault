表示两个变量之间的运算，包括赋值运算符，算术运算符，逻辑运算符等，运算符的效果分为结果和副作用两部分。

* 赋值运算符
    * `=`：将一个值（字面量，表达式值，变量等）传递给等号前的变量
    * `op=`：`op` 表示任意一个二元运算符，`a op= b` 等效于 `a = a op b`
* 自增/自减运算符
    * `++`，`--`：副作用为自增/自减 1，`++/--` 放在前面运算结果是自增后的值，放在后面为自增前的值
* 算术运算符：数字之间的数学运算
    * `+`, `-`, `*`：与数学上完全相同
    * `+` / `-` 在表示一个数字的正负值时也是运算符
    * `/`：与数学上的除法不同，若两个整型相除，返回值仍为整型，小数部分将直接忽略
    * `%`：取余（取模）
    * 位运算符：按二进制位进行运算
        * `&`, `|`, `^`, `~`  分别表示且，或，异或，非
        * `<<`, `>>` 表示按位左/右移
* 逻辑运算符：针对 `bool` 类型的运算
    * `!`, `&&`, `||` 分别表示非，且，或
* 比较运算符：由其他类型生成 `bool` 类型值的运算，主要是大小关系的比较
    * `==`， `!=`，`>`，>=，`<`，`<=`：相等/不等/大小比较，可[[#比较运算符|自动生成]]
    * `<=>`：使用一个运算符比较大小
* 其他运算符：函数调用 `()`，逗号运算符 `,`，条件运算符 `?:` 等
    * 成员访问：下标运算符 `[]`，作用域解析 `::`，成员访问 `.`
	    * [[#多参数下标运算符|下标运算符支持多个参数]]
    * 指针：取址 `&`，寻址 `*`，指针访问 `->` 等
    * 类型转换，`new`，`delete`，`sizeof`，`typeid`，`noexcept`，`alignof` 甚至 `throw` 等
# 优先级

运算符执行的优先级，自上而下不断降低，未标记自左向右降低：
* `::`, `()`, `[]`, `->`, 后缀 `++`、`--`, `typeid`, 类型强制转换
* 自右向左降低：`!`, 正负值 `+`、`-`, 前缀 `++`、`--`, 取址 `&`, `*`, 类型强转 `()`, `sizeof`, `decltype`, `new`, `new[]`, `delete`, `delete[]`
* `.*`, `->*`
* 算术运算 `*`, `/`, `+`, `-`, `<<`, `>>`
* 位与布尔运算 `==`, `!=`, `&`, `^`, `|`, `&&`, `||`
* `?:`
* 自右向左降低：`=`, `*=`, `/=`, `%=`, `+=`, `-=`, `&=`, `^=`, `|=`, `<<=`, `>>=`
* `throw`, `,`
# 运算符重载

在 C++ 中，一个类型的大多数运算符都可以重载，除了
* `::` 作用域解析运算符，用于访问类的静态成员
* `?:` 三元运算符
* `.` 直接成员选择运算符，用于通过对象直接访问成员（没错这也是运算符）
* `sizeof` 操作符，用于计算类占用内存字节数
* `.*` 指针解引用操作符

运算符重载通过声明以 `operator 运算符` 为名的函数重载

```cpp
class A {
public:
    bool operator<(const A& other) const;
}
```

`operator` 和运算符之间可以没有空格，也可以添加空格。但若操作符是单词，如 `new` 和 `delete`，则 `operator` 之后需要空格避免歧义。

运算符支持 `const` 修饰符，当重载的运算符不修改原对象时，应当使用 `const` 修饰。

重载运算符可以不在类中，只需要提供足够的参数即可。

* `operator()()` 重载了 `()` 运算符，这类对象可像函数一样调用，是一种仿函数，如 λ 表达式
* `operator=()` 重载赋值运算符
* `++`，`--` 重载时，前后缀通过参数列表体现：
    * `T& operator++()` --> ++a
    * `T& operaotr++(T)` --> a++
* 比较运算符只需要重载 `<` 和 `==` 运算符即可，剩下的可以通过使用标准库中 `std::rel_ops` 命名空间的相关函数直接实现。
## 比较运算符

早期，C++ `std::rel_ops` 头文件允许根据 `==`，`<` 两个运算符生成其他自定义运算符。

#cpp20 只要实现了 [[#<=>|<=>]] 运算符，编译器将自动生成对应的 `<`，`>`，`<=`，>= 四种运算符。

> [!warning] 由于性能问题，`==` 运算符并没有从  *`<=>`*  中派生。但定义了 `==`  运算符的对象可以直接生成  `!=`  运算符

在实现了 `<`，`==` 运算符后，可以手动声明实现默认的 `<=>` 运算符

```cpp
struct Data {
    bool operator==(const Data &rhs) const { ... }
    bool operator<(const Data &rhs) const { ... }
};

struct ThreeWay {
    Data m;
    // 调用了 Data 的对应函数
    std::strong_ordering operator<=>(const ThreeWay &rhs) const = default;
```
## <=>
#cpp20 

实现了 `<=>` 运算符的类或结构体相当于同时生成 `==`，`!=`，`<`，`>`，`<=`，>=。

$a<=>b\begin{cases} >0&a>b\\  =0&a=b\\ <0&a<b \end{cases}$

根据约束力的强弱，`<=>` 运算符的返回值有三种类型可选：

|类型|可选值|约束力说明|示例|
| ------| ------------------| -------------------------------------------------------------------| ------------------------------------------|
| `std::strong_ordering` | `less`，`equal`，`greater` |强调可替换性，当 `a<=>b` 值为 `equal` 时，`a`，`b` 可以互相替换|整形，布尔值|
| `str::weak_ordering` | `less`，`equivalent`，`greater` |强调不可替换性，当 `a<=>b` 非 `equivalent` 时，`a`，`b` 不可替换，但反之不一定成立|标准库中无，如某些大小写不敏感的字符串类|
| `str::partial_ordering` | `less`，`equivalent`，`greater`，`unordered` |约束力最弱，支持两个值不可比较大小的情况|浮点数，存在 `NaN` 不可与其他数字比较|
* 枚举之间进行比较，若基类型不同，则不可比较；否则转换为整形比较
* 枚举与整形之间比较，枚举转换为整形后进行比较；枚举不能与浮点数比较
* 布尔值只能与布尔值进行比较
* 数组之间不能直接进行比较，指针只能与另一个（可隐式转换为）同类型的指针进行比较
## 按值默认比较
#cpp20 

类 `C` 的默认 `==` 运算符可以是一个参数为 `const &C` 的非静态成员函数，或两个参数都是 `const &C` 或 `C` 的友元函数（原本只能是 `const &C`）

```cpp

struct C {
    // 没问题
    bool operator==(const C &o) const = default;
    friend bool operator==(C c1, C c2) = default;
    friend bool operator==(const C &c1, const C &c2) = default;

    // error: defaulted member 'bool C::operator==(C) const' must have parameter type 'const C&'
    bool operator==(C o) const = default;
    // error: defaulted 'bool operator==(C, const C&)' must have parameters of either type 'const C&' or 'C', not both
    friend bool operator==(C c1, const C &c2) = default;
};
```
# 多参数下标运算符
#cpp23

`[]` 允许使用 `,` 分隔的多个参数，避免 `arr[i][j][k]` 这种写法。`[]` 运算符重载时也可以传入多个参数。

> [!danger] 该特性易引发兼容性错误
> - C++20 以前，`[]` 内存在 `,` 被认为是逗号运算符
> - C++20 开始，`[]` 内的逗号触发警告，但仍被认为是逗号运算符
> - C++23 之后，`[]` 内逗号可以是多个参数

```cpp
class Matrix {
    int values[4][4];
public:
    // [] 运算符带了两个参数
    int &operator[](int row, int col) {
        return values[row % 4][col % 4];
    }
};

int main() {
    Matrix m {};
    // 使用两个参数访问矩阵元素
    m[1, 3] = 5;
    return 0;
}
```
# 静态 () 运算符
#cpp23

`operator()` 运算符可以是静态成员函数了，可用于提高效率 - 节省一次 `this` 传递。

只需要在前面加上 `static` 声明即可

```cpp
template<typename T>
struct less {
    static bool operator()(const T& x, const T& y) {
        return x < y;
    }
}

less<int>{}(2, 3);
```

lambda 表达式也可以使用 -- 在 `[]()` 与 `{}` 之间添加 `static` 关键字即可。
